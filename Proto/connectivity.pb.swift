// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: arsdk/connectivity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Arsdk_Connectivity_CommandStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ok // = 0
  case busy // = 1
  case notAllowed // = 2
  case already // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .ok
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .busy
    case 2: self = .notAllowed
    case 3: self = .already
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ok: return 0
    case .busy: return 1
    case .notAllowed: return 2
    case .already: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Connectivity_CommandStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Connectivity_CommandStatus] = [
    .ok,
    .busy,
    .notAllowed,
    .already,
  ]
}

#endif  // swift(>=4.2)

enum Arsdk_Connectivity_ConnectionStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case disconnected // = 0
  case authFailure // = 1
  case failure // = 2
  case connected // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .disconnected
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .disconnected
    case 1: self = .authFailure
    case 2: self = .failure
    case 3: self = .connected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .disconnected: return 0
    case .authFailure: return 1
    case .failure: return 2
    case .connected: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Connectivity_ConnectionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Connectivity_ConnectionStatus] = [
    .disconnected,
    .authFailure,
    .failure,
    .connected,
  ]
}

#endif  // swift(>=4.2)

enum Arsdk_Connectivity_EncryptionType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case `open` // = 0
  case wep // = 1
  case wpa // = 2
  case wpa2 // = 3

  /// ENCRYPTION_TYPE_AES_128 = 3
  /// ENCRYPTION_TYPE_AES_256 = 4
  case wpa3 // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .open
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .open
    case 1: self = .wep
    case 2: self = .wpa
    case 3: self = .wpa2
    case 4: self = .wpa3
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .open: return 0
    case .wep: return 1
    case .wpa: return 2
    case .wpa2: return 3
    case .wpa3: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Connectivity_EncryptionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Connectivity_EncryptionType] = [
    .open,
    .wep,
    .wpa,
    .wpa2,
    .wpa3,
  ]
}

#endif  // swift(>=4.2)

enum Arsdk_Connectivity_Environment: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case indoor // = 0
  case outdoor // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .indoor
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .indoor
    case 1: self = .outdoor
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .indoor: return 0
    case .outdoor: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Connectivity_Environment: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Connectivity_Environment] = [
    .indoor,
    .outdoor,
  ]
}

#endif  // swift(>=4.2)

enum Arsdk_Connectivity_Mode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ap // = 0
  case sta // = 1
  case idle // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .ap
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ap
    case 1: self = .sta
    case 2: self = .idle
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ap: return 0
    case .sta: return 1
    case .idle: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Connectivity_Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Connectivity_Mode] = [
    .ap,
    .sta,
    .idle,
  ]
}

#endif  // swift(>=4.2)

enum Arsdk_Connectivity_RadioType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// RADIO_TYPE_MICROHARD = 1;
  /// RADIO_TYPE_SIMPULSE = 2;
  case wifi // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .wifi
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .wifi
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .wifi: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Connectivity_RadioType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Connectivity_RadioType] = [
    .wifi,
  ]
}

#endif  // swift(>=4.2)

enum Arsdk_Connectivity_StationConnectionState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case connecting // = 0
  case connected // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .connecting
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .connecting
    case 1: self = .connected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .connecting: return 0
    case .connected: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Connectivity_StationConnectionState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Connectivity_StationConnectionState] = [
    .connecting,
    .connected,
  ]
}

#endif  // swift(>=4.2)

enum Arsdk_Connectivity_SystemState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case stopping // = 0
  case starting // = 1
  case running // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .stopping
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stopping
    case 1: self = .starting
    case 2: self = .running
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .stopping: return 0
    case .starting: return 1
    case .running: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Connectivity_SystemState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Connectivity_SystemState] = [
    .stopping,
    .starting,
    .running,
  ]
}

#endif  // swift(>=4.2)

enum Arsdk_Connectivity_WifiBand: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case wifiBand24Ghz // = 0
  case wifiBand5Ghz // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .wifiBand24Ghz
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .wifiBand24Ghz
    case 1: self = .wifiBand5Ghz
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .wifiBand24Ghz: return 0
    case .wifiBand5Ghz: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Connectivity_WifiBand: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Connectivity_WifiBand] = [
    .wifiBand24Ghz,
    .wifiBand5Ghz,
  ]
}

#endif  // swift(>=4.2)

/// This is the entry point to send messages to the device
struct Arsdk_Connectivity_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Arsdk_Connectivity_Command.OneOf_ID? = nil

  var listRadios: Arsdk_Connectivity_Command.ListRadios {
    get {
      if case .listRadios(let v)? = id {return v}
      return Arsdk_Connectivity_Command.ListRadios()
    }
    set {id = .listRadios(newValue)}
  }

  var getState: Arsdk_Connectivity_Command.GetState {
    get {
      if case .getState(let v)? = id {return v}
      return Arsdk_Connectivity_Command.GetState()
    }
    set {id = .getState(newValue)}
  }

  var setMode: Arsdk_Connectivity_Command.SetMode {
    get {
      if case .setMode(let v)? = id {return v}
      return Arsdk_Connectivity_Command.SetMode()
    }
    set {id = .setMode(newValue)}
  }

  var scan: Arsdk_Connectivity_Command.Scan {
    get {
      if case .scan(let v)? = id {return v}
      return Arsdk_Connectivity_Command.Scan()
    }
    set {id = .scan(newValue)}
  }

  var configure: Arsdk_Connectivity_Command.Configure {
    get {
      if case .configure(let v)? = id {return v}
      return Arsdk_Connectivity_Command.Configure()
    }
    set {id = .configure(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case listRadios(Arsdk_Connectivity_Command.ListRadios)
    case getState(Arsdk_Connectivity_Command.GetState)
    case setMode(Arsdk_Connectivity_Command.SetMode)
    case scan(Arsdk_Connectivity_Command.Scan)
    case configure(Arsdk_Connectivity_Command.Configure)

  #if !swift(>=4.1)
    static func ==(lhs: Arsdk_Connectivity_Command.OneOf_ID, rhs: Arsdk_Connectivity_Command.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.listRadios, .listRadios): return {
        guard case .listRadios(let l) = lhs, case .listRadios(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getState, .getState): return {
        guard case .getState(let l) = lhs, case .getState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setMode, .setMode): return {
        guard case .setMode(let l) = lhs, case .setMode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scan, .scan): return {
        guard case .scan(let l) = lhs, case .scan(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configure, .configure): return {
        guard case .configure(let l) = lhs, case .configure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct ListRadios {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var typeFilter: [Arsdk_Connectivity_RadioType] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var radioID: UInt32 = 0

    var includeDefaultCapabilities: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetMode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var radioID: UInt32 = 0

    var mode: Arsdk_Connectivity_Mode = .ap

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Scans the list of available networks
  struct Scan {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var radioID: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Configure {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var radioID: UInt32 = 0

    var mode: Arsdk_Connectivity_Command.Configure.OneOf_Mode? = nil

    var accessPointConfig: Arsdk_Connectivity_AccessPointConfig {
      get {
        if case .accessPointConfig(let v)? = mode {return v}
        return Arsdk_Connectivity_AccessPointConfig()
      }
      set {mode = .accessPointConfig(newValue)}
    }

    var stationConfig: Arsdk_Connectivity_StationConfig {
      get {
        if case .stationConfig(let v)? = mode {return v}
        return Arsdk_Connectivity_StationConfig()
      }
      set {mode = .stationConfig(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Mode: Equatable {
      case accessPointConfig(Arsdk_Connectivity_AccessPointConfig)
      case stationConfig(Arsdk_Connectivity_StationConfig)

    #if !swift(>=4.1)
      static func ==(lhs: Arsdk_Connectivity_Command.Configure.OneOf_Mode, rhs: Arsdk_Connectivity_Command.Configure.OneOf_Mode) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.accessPointConfig, .accessPointConfig): return {
          guard case .accessPointConfig(let l) = lhs, case .accessPointConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.stationConfig, .stationConfig): return {
          guard case .stationConfig(let l) = lhs, case .stationConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}
}

/// This is the entry point to receive messages from the drone
struct Arsdk_Connectivity_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Arsdk_Connectivity_Event.OneOf_ID? = nil

  var radioList: Arsdk_Connectivity_Event.RadioList {
    get {
      if case .radioList(let v)? = id {return v}
      return Arsdk_Connectivity_Event.RadioList()
    }
    set {id = .radioList(newValue)}
  }

  var state: Arsdk_Connectivity_Event.State {
    get {
      if case .state(let v)? = id {return v}
      return Arsdk_Connectivity_Event.State()
    }
    set {id = .state(newValue)}
  }

  var commandResponse: Arsdk_Connectivity_Event.CommandResponse {
    get {
      if case .commandResponse(let v)? = id {return v}
      return Arsdk_Connectivity_Event.CommandResponse()
    }
    set {id = .commandResponse(newValue)}
  }

  var connection: Arsdk_Connectivity_Event.Connection {
    get {
      if case .connection(let v)? = id {return v}
      return Arsdk_Connectivity_Event.Connection()
    }
    set {id = .connection(newValue)}
  }

  var scanResult: Arsdk_Connectivity_Event.ScanResult {
    get {
      if case .scanResult(let v)? = id {return v}
      return Arsdk_Connectivity_Event.ScanResult()
    }
    set {id = .scanResult(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case radioList(Arsdk_Connectivity_Event.RadioList)
    case state(Arsdk_Connectivity_Event.State)
    case commandResponse(Arsdk_Connectivity_Event.CommandResponse)
    case connection(Arsdk_Connectivity_Event.Connection)
    case scanResult(Arsdk_Connectivity_Event.ScanResult)

  #if !swift(>=4.1)
    static func ==(lhs: Arsdk_Connectivity_Event.OneOf_ID, rhs: Arsdk_Connectivity_Event.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.radioList, .radioList): return {
        guard case .radioList(let l) = lhs, case .radioList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.state, .state): return {
        guard case .state(let l) = lhs, case .state(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commandResponse, .commandResponse): return {
        guard case .commandResponse(let l) = lhs, case .commandResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connection, .connection): return {
        guard case .connection(let l) = lhs, case .connection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scanResult, .scanResult): return {
        guard case .scanResult(let l) = lhs, case .scanResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct RadioList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var radios: Dictionary<UInt32,Arsdk_Connectivity_RadioType> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Current state
  struct State {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var radioID: UInt32 {
      get {return _storage._radioID}
      set {_uniqueStorage()._radioID = newValue}
    }

    var defaultCapabilities: Arsdk_Connectivity_Capabilities {
      get {return _storage._defaultCapabilities ?? Arsdk_Connectivity_Capabilities()}
      set {_uniqueStorage()._defaultCapabilities = newValue}
    }
    /// Returns true if `defaultCapabilities` has been explicitly set.
    var hasDefaultCapabilities: Bool {return _storage._defaultCapabilities != nil}
    /// Clears the value of `defaultCapabilities`. Subsequent reads from it will return its default value.
    mutating func clearDefaultCapabilities() {_uniqueStorage()._defaultCapabilities = nil}

    var accessPointConfig: Arsdk_Connectivity_AccessPointConfig {
      get {return _storage._accessPointConfig ?? Arsdk_Connectivity_AccessPointConfig()}
      set {_uniqueStorage()._accessPointConfig = newValue}
    }
    /// Returns true if `accessPointConfig` has been explicitly set.
    var hasAccessPointConfig: Bool {return _storage._accessPointConfig != nil}
    /// Clears the value of `accessPointConfig`. Subsequent reads from it will return its default value.
    mutating func clearAccessPointConfig() {_uniqueStorage()._accessPointConfig = nil}

    var stationConfig: Arsdk_Connectivity_StationConfig {
      get {return _storage._stationConfig ?? Arsdk_Connectivity_StationConfig()}
      set {_uniqueStorage()._stationConfig = newValue}
    }
    /// Returns true if `stationConfig` has been explicitly set.
    var hasStationConfig: Bool {return _storage._stationConfig != nil}
    /// Clears the value of `stationConfig`. Subsequent reads from it will return its default value.
    mutating func clearStationConfig() {_uniqueStorage()._stationConfig = nil}

    var mode: OneOf_Mode? {
      get {return _storage._mode}
      set {_uniqueStorage()._mode = newValue}
    }

    var idle: Arsdk_Connectivity_IdleState {
      get {
        if case .idle(let v)? = _storage._mode {return v}
        return Arsdk_Connectivity_IdleState()
      }
      set {_uniqueStorage()._mode = .idle(newValue)}
    }

    var accessPoint: Arsdk_Connectivity_AccessPointState {
      get {
        if case .accessPoint(let v)? = _storage._mode {return v}
        return Arsdk_Connectivity_AccessPointState()
      }
      set {_uniqueStorage()._mode = .accessPoint(newValue)}
    }

    var station: Arsdk_Connectivity_StationState {
      get {
        if case .station(let v)? = _storage._mode {return v}
        return Arsdk_Connectivity_StationState()
      }
      set {_uniqueStorage()._mode = .station(newValue)}
    }

    var channel: Arsdk_Connectivity_Channel {
      get {return _storage._channel ?? Arsdk_Connectivity_Channel()}
      set {_uniqueStorage()._channel = newValue}
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool {return _storage._channel != nil}
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() {_uniqueStorage()._channel = nil}

    /// NOTE: the authorized channels are given for the _current mode_ country 
    ///       configuration only.
    var authorizedChannels: Arsdk_Connectivity_AuthorizedChannels {
      get {return _storage._authorizedChannels ?? Arsdk_Connectivity_AuthorizedChannels()}
      set {_uniqueStorage()._authorizedChannels = newValue}
    }
    /// Returns true if `authorizedChannels` has been explicitly set.
    var hasAuthorizedChannels: Bool {return _storage._authorizedChannels != nil}
    /// Clears the value of `authorizedChannels`. Subsequent reads from it will return its default value.
    mutating func clearAuthorizedChannels() {_uniqueStorage()._authorizedChannels = nil}

    var rssi: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _storage._rssi ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_uniqueStorage()._rssi = newValue}
    }
    /// Returns true if `rssi` has been explicitly set.
    var hasRssi: Bool {return _storage._rssi != nil}
    /// Clears the value of `rssi`. Subsequent reads from it will return its default value.
    mutating func clearRssi() {_uniqueStorage()._rssi = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Mode: Equatable {
      case idle(Arsdk_Connectivity_IdleState)
      case accessPoint(Arsdk_Connectivity_AccessPointState)
      case station(Arsdk_Connectivity_StationState)

    #if !swift(>=4.1)
      static func ==(lhs: Arsdk_Connectivity_Event.State.OneOf_Mode, rhs: Arsdk_Connectivity_Event.State.OneOf_Mode) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.idle, .idle): return {
          guard case .idle(let l) = lhs, case .idle(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.accessPoint, .accessPoint): return {
          guard case .accessPoint(let l) = lhs, case .accessPoint(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.station, .station): return {
          guard case .station(let l) = lhs, case .station(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct CommandResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var radioID: UInt32 = 0

    var status: Arsdk_Connectivity_CommandStatus = .ok

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Connection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var radioID: UInt32 = 0

    var status: Arsdk_Connectivity_ConnectionStatus = .disconnected

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ScanResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var radioID: UInt32 = 0

    var networks: [Arsdk_Connectivity_Network] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Arsdk_Connectivity_Capabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var supportedModes: [Arsdk_Connectivity_Mode] = []

  var supportedEncryptionTypes: [Arsdk_Connectivity_EncryptionType] = []

  var supportedCountries: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Connectivity_AccessPointConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var security: Arsdk_Connectivity_NetworkSecurityMode {
    get {return _security ?? Arsdk_Connectivity_NetworkSecurityMode()}
    set {_security = newValue}
  }
  /// Returns true if `security` has been explicitly set.
  var hasSecurity: Bool {return self._security != nil}
  /// Clears the value of `security`. Subsequent reads from it will return its default value.
  mutating func clearSecurity() {self._security = nil}

  var ssid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _ssid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_ssid = newValue}
  }
  /// Returns true if `ssid` has been explicitly set.
  var hasSsid: Bool {return self._ssid != nil}
  /// Clears the value of `ssid`. Subsequent reads from it will return its default value.
  mutating func clearSsid() {self._ssid = nil}

  var hidden: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _hidden ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_hidden = newValue}
  }
  /// Returns true if `hidden` has been explicitly set.
  var hasHidden: Bool {return self._hidden != nil}
  /// Clears the value of `hidden`. Subsequent reads from it will return its default value.
  mutating func clearHidden() {self._hidden = nil}

  var hwAddr: SwiftProtobuf.Google_Protobuf_BytesValue {
    get {return _hwAddr ?? SwiftProtobuf.Google_Protobuf_BytesValue()}
    set {_hwAddr = newValue}
  }
  /// Returns true if `hwAddr` has been explicitly set.
  var hasHwAddr: Bool {return self._hwAddr != nil}
  /// Clears the value of `hwAddr`. Subsequent reads from it will return its default value.
  mutating func clearHwAddr() {self._hwAddr = nil}

  var country: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _country ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_country = newValue}
  }
  /// Returns true if `country` has been explicitly set.
  var hasCountry: Bool {return self._country != nil}
  /// Clears the value of `country`. Subsequent reads from it will return its default value.
  mutating func clearCountry() {self._country = nil}

  var environment: Arsdk_Connectivity_EnvironmentValue {
    get {return _environment ?? Arsdk_Connectivity_EnvironmentValue()}
    set {_environment = newValue}
  }
  /// Returns true if `environment` has been explicitly set.
  var hasEnvironment: Bool {return self._environment != nil}
  /// Clears the value of `environment`. Subsequent reads from it will return its default value.
  mutating func clearEnvironment() {self._environment = nil}

  var channelSelectionType: Arsdk_Connectivity_AccessPointConfig.OneOf_ChannelSelectionType? = nil

  var manualChannel: Arsdk_Connectivity_Channel {
    get {
      if case .manualChannel(let v)? = channelSelectionType {return v}
      return Arsdk_Connectivity_Channel()
    }
    set {channelSelectionType = .manualChannel(newValue)}
  }

  var automaticChannel: Arsdk_Connectivity_AutomaticChannelSelection {
    get {
      if case .automaticChannel(let v)? = channelSelectionType {return v}
      return Arsdk_Connectivity_AutomaticChannelSelection()
    }
    set {channelSelectionType = .automaticChannel(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ChannelSelectionType: Equatable {
    case manualChannel(Arsdk_Connectivity_Channel)
    case automaticChannel(Arsdk_Connectivity_AutomaticChannelSelection)

  #if !swift(>=4.1)
    static func ==(lhs: Arsdk_Connectivity_AccessPointConfig.OneOf_ChannelSelectionType, rhs: Arsdk_Connectivity_AccessPointConfig.OneOf_ChannelSelectionType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.manualChannel, .manualChannel): return {
        guard case .manualChannel(let l) = lhs, case .manualChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.automaticChannel, .automaticChannel): return {
        guard case .automaticChannel(let l) = lhs, case .automaticChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _security: Arsdk_Connectivity_NetworkSecurityMode? = nil
  fileprivate var _ssid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _hidden: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _hwAddr: SwiftProtobuf.Google_Protobuf_BytesValue? = nil
  fileprivate var _country: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _environment: Arsdk_Connectivity_EnvironmentValue? = nil
}

struct Arsdk_Connectivity_StationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var security: Arsdk_Connectivity_NetworkSecurityMode {
    get {return _security ?? Arsdk_Connectivity_NetworkSecurityMode()}
    set {_security = newValue}
  }
  /// Returns true if `security` has been explicitly set.
  var hasSecurity: Bool {return self._security != nil}
  /// Clears the value of `security`. Subsequent reads from it will return its default value.
  mutating func clearSecurity() {self._security = nil}

  var ssid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _ssid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_ssid = newValue}
  }
  /// Returns true if `ssid` has been explicitly set.
  var hasSsid: Bool {return self._ssid != nil}
  /// Clears the value of `ssid`. Subsequent reads from it will return its default value.
  mutating func clearSsid() {self._ssid = nil}

  var hidden: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _hidden ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_hidden = newValue}
  }
  /// Returns true if `hidden` has been explicitly set.
  var hasHidden: Bool {return self._hidden != nil}
  /// Clears the value of `hidden`. Subsequent reads from it will return its default value.
  mutating func clearHidden() {self._hidden = nil}

  var hwAddr: SwiftProtobuf.Google_Protobuf_BytesValue {
    get {return _hwAddr ?? SwiftProtobuf.Google_Protobuf_BytesValue()}
    set {_hwAddr = newValue}
  }
  /// Returns true if `hwAddr` has been explicitly set.
  var hasHwAddr: Bool {return self._hwAddr != nil}
  /// Clears the value of `hwAddr`. Subsequent reads from it will return its default value.
  mutating func clearHwAddr() {self._hwAddr = nil}

  var country: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _country ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_country = newValue}
  }
  /// Returns true if `country` has been explicitly set.
  var hasCountry: Bool {return self._country != nil}
  /// Clears the value of `country`. Subsequent reads from it will return its default value.
  mutating func clearCountry() {self._country = nil}

  var environment: Arsdk_Connectivity_EnvironmentValue {
    get {return _environment ?? Arsdk_Connectivity_EnvironmentValue()}
    set {_environment = newValue}
  }
  /// Returns true if `environment` has been explicitly set.
  var hasEnvironment: Bool {return self._environment != nil}
  /// Clears the value of `environment`. Subsequent reads from it will return its default value.
  mutating func clearEnvironment() {self._environment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _security: Arsdk_Connectivity_NetworkSecurityMode? = nil
  fileprivate var _ssid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _hidden: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _hwAddr: SwiftProtobuf.Google_Protobuf_BytesValue? = nil
  fileprivate var _country: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _environment: Arsdk_Connectivity_EnvironmentValue? = nil
}

struct Arsdk_Connectivity_IdleState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Connectivity_AccessPointState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var systemState: Arsdk_Connectivity_SystemState = .stopping

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Connectivity_StationState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var systemState: Arsdk_Connectivity_SystemState = .stopping

  var connectionState: Arsdk_Connectivity_StationConnectionState = .connecting

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Connectivity_Channel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Arsdk_Connectivity_Channel.OneOf_Type? = nil

  /// MicrohardChannel microhard_channel = 2;
  /// SimpulseChannel simpulse_channel = 3;
  var wifiChannel: Arsdk_Connectivity_WifiChannel {
    get {
      if case .wifiChannel(let v)? = type {return v}
      return Arsdk_Connectivity_WifiChannel()
    }
    set {type = .wifiChannel(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    /// MicrohardChannel microhard_channel = 2;
    /// SimpulseChannel simpulse_channel = 3;
    case wifiChannel(Arsdk_Connectivity_WifiChannel)

  #if !swift(>=4.1)
    static func ==(lhs: Arsdk_Connectivity_Channel.OneOf_Type, rhs: Arsdk_Connectivity_Channel.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.wifiChannel, .wifiChannel): return {
        guard case .wifiChannel(let l) = lhs, case .wifiChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct Arsdk_Connectivity_WifiChannel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var band: Arsdk_Connectivity_WifiBand = .wifiBand24Ghz

  var channel: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Connectivity_AuthorizedChannels {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: [Arsdk_Connectivity_AuthorizedChannel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Connectivity_AuthorizedChannel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: Arsdk_Connectivity_Channel {
    get {return _channel ?? Arsdk_Connectivity_Channel()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  mutating func clearChannel() {self._channel = nil}

  var environment: Arsdk_Connectivity_Environment = .indoor

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _channel: Arsdk_Connectivity_Channel? = nil
}

struct Arsdk_Connectivity_NetworkSecurityMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: some modes, for example STA, only support a single encryption type; 
  ///       in that case only the first listed value will be considered
  var encryption: [Arsdk_Connectivity_EncryptionType] = []

  /// NOTE: irrelevant for OPEN encryption type.
  var passphrase: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Connectivity_Network {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: Arsdk_Connectivity_Channel {
    get {return _channel ?? Arsdk_Connectivity_Channel()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  mutating func clearChannel() {self._channel = nil}

  var encryption: [Arsdk_Connectivity_EncryptionType] = []

  var ssid: String = String()

  /// Beacon information elements
  var bie: [Arsdk_Connectivity_Bie] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _channel: Arsdk_Connectivity_Channel? = nil
}

/// Beacon Information Element
struct Arsdk_Connectivity_Bie {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Organizationally Unique Identifier
  var oui: Data = Data()

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Connectivity_EnvironmentValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Arsdk_Connectivity_Environment = .indoor

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Connectivity_AutomaticChannelSelection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var allowedBands: [Arsdk_Connectivity_WifiBand] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Arsdk_Connectivity_CommandStatus: @unchecked Sendable {}
extension Arsdk_Connectivity_ConnectionStatus: @unchecked Sendable {}
extension Arsdk_Connectivity_EncryptionType: @unchecked Sendable {}
extension Arsdk_Connectivity_Environment: @unchecked Sendable {}
extension Arsdk_Connectivity_Mode: @unchecked Sendable {}
extension Arsdk_Connectivity_RadioType: @unchecked Sendable {}
extension Arsdk_Connectivity_StationConnectionState: @unchecked Sendable {}
extension Arsdk_Connectivity_SystemState: @unchecked Sendable {}
extension Arsdk_Connectivity_WifiBand: @unchecked Sendable {}
extension Arsdk_Connectivity_Command: @unchecked Sendable {}
extension Arsdk_Connectivity_Command.OneOf_ID: @unchecked Sendable {}
extension Arsdk_Connectivity_Command.ListRadios: @unchecked Sendable {}
extension Arsdk_Connectivity_Command.GetState: @unchecked Sendable {}
extension Arsdk_Connectivity_Command.SetMode: @unchecked Sendable {}
extension Arsdk_Connectivity_Command.Scan: @unchecked Sendable {}
extension Arsdk_Connectivity_Command.Configure: @unchecked Sendable {}
extension Arsdk_Connectivity_Command.Configure.OneOf_Mode: @unchecked Sendable {}
extension Arsdk_Connectivity_Event: @unchecked Sendable {}
extension Arsdk_Connectivity_Event.OneOf_ID: @unchecked Sendable {}
extension Arsdk_Connectivity_Event.RadioList: @unchecked Sendable {}
extension Arsdk_Connectivity_Event.State: @unchecked Sendable {}
extension Arsdk_Connectivity_Event.State.OneOf_Mode: @unchecked Sendable {}
extension Arsdk_Connectivity_Event.CommandResponse: @unchecked Sendable {}
extension Arsdk_Connectivity_Event.Connection: @unchecked Sendable {}
extension Arsdk_Connectivity_Event.ScanResult: @unchecked Sendable {}
extension Arsdk_Connectivity_Capabilities: @unchecked Sendable {}
extension Arsdk_Connectivity_AccessPointConfig: @unchecked Sendable {}
extension Arsdk_Connectivity_AccessPointConfig.OneOf_ChannelSelectionType: @unchecked Sendable {}
extension Arsdk_Connectivity_StationConfig: @unchecked Sendable {}
extension Arsdk_Connectivity_IdleState: @unchecked Sendable {}
extension Arsdk_Connectivity_AccessPointState: @unchecked Sendable {}
extension Arsdk_Connectivity_StationState: @unchecked Sendable {}
extension Arsdk_Connectivity_Channel: @unchecked Sendable {}
extension Arsdk_Connectivity_Channel.OneOf_Type: @unchecked Sendable {}
extension Arsdk_Connectivity_WifiChannel: @unchecked Sendable {}
extension Arsdk_Connectivity_AuthorizedChannels: @unchecked Sendable {}
extension Arsdk_Connectivity_AuthorizedChannel: @unchecked Sendable {}
extension Arsdk_Connectivity_NetworkSecurityMode: @unchecked Sendable {}
extension Arsdk_Connectivity_Network: @unchecked Sendable {}
extension Arsdk_Connectivity_Bie: @unchecked Sendable {}
extension Arsdk_Connectivity_EnvironmentValue: @unchecked Sendable {}
extension Arsdk_Connectivity_AutomaticChannelSelection: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "arsdk.connectivity"

extension Arsdk_Connectivity_CommandStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_STATUS_OK"),
    1: .same(proto: "COMMAND_STATUS_BUSY"),
    2: .same(proto: "COMMAND_STATUS_NOT_ALLOWED"),
    3: .same(proto: "COMMAND_STATUS_ALREADY"),
  ]
}

extension Arsdk_Connectivity_ConnectionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECTION_STATUS_DISCONNECTED"),
    1: .same(proto: "CONNECTION_STATUS_AUTH_FAILURE"),
    2: .same(proto: "CONNECTION_STATUS_FAILURE"),
    3: .same(proto: "CONNECTION_STATUS_CONNECTED"),
  ]
}

extension Arsdk_Connectivity_EncryptionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENCRYPTION_TYPE_OPEN"),
    1: .same(proto: "ENCRYPTION_TYPE_WEP"),
    2: .same(proto: "ENCRYPTION_TYPE_WPA"),
    3: .same(proto: "ENCRYPTION_TYPE_WPA2"),
    4: .same(proto: "ENCRYPTION_TYPE_WPA3"),
  ]
}

extension Arsdk_Connectivity_Environment: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENVIRONMENT_INDOOR"),
    1: .same(proto: "ENVIRONMENT_OUTDOOR"),
  ]
}

extension Arsdk_Connectivity_Mode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODE_AP"),
    1: .same(proto: "MODE_STA"),
    2: .same(proto: "MODE_IDLE"),
  ]
}

extension Arsdk_Connectivity_RadioType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RADIO_TYPE_WIFI"),
  ]
}

extension Arsdk_Connectivity_StationConnectionState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATION_CONNECTION_STATE_CONNECTING"),
    1: .same(proto: "STATION_CONNECTION_STATE_CONNECTED"),
  ]
}

extension Arsdk_Connectivity_SystemState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYSTEM_STATE_STOPPING"),
    1: .same(proto: "SYSTEM_STATE_STARTING"),
    2: .same(proto: "SYSTEM_STATE_RUNNING"),
  ]
}

extension Arsdk_Connectivity_WifiBand: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WIFI_BAND_2_4_GHZ"),
    1: .same(proto: "WIFI_BAND_5_GHZ"),
  ]
}

extension Arsdk_Connectivity_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    16: .standard(proto: "list_radios"),
    17: .standard(proto: "get_state"),
    18: .standard(proto: "set_mode"),
    19: .same(proto: "scan"),
    20: .same(proto: "configure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 16: try {
        var v: Arsdk_Connectivity_Command.ListRadios?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .listRadios(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .listRadios(v)
        }
      }()
      case 17: try {
        var v: Arsdk_Connectivity_Command.GetState?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .getState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .getState(v)
        }
      }()
      case 18: try {
        var v: Arsdk_Connectivity_Command.SetMode?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .setMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .setMode(v)
        }
      }()
      case 19: try {
        var v: Arsdk_Connectivity_Command.Scan?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .scan(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .scan(v)
        }
      }()
      case 20: try {
        var v: Arsdk_Connectivity_Command.Configure?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .configure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .configure(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .listRadios?: try {
      guard case .listRadios(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .getState?: try {
      guard case .getState(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .setMode?: try {
      guard case .setMode(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .scan?: try {
      guard case .scan(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .configure?: try {
      guard case .configure(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Command, rhs: Arsdk_Connectivity_Command) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Command.ListRadios: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Connectivity_Command.protoMessageName + ".ListRadios"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.typeFilter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typeFilter.isEmpty {
      try visitor.visitPackedEnumField(value: self.typeFilter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Command.ListRadios, rhs: Arsdk_Connectivity_Command.ListRadios) -> Bool {
    if lhs.typeFilter != rhs.typeFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Command.GetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Connectivity_Command.protoMessageName + ".GetState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "radio_id"),
    2: .standard(proto: "include_default_capabilities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.radioID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeDefaultCapabilities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.radioID != 0 {
      try visitor.visitSingularUInt32Field(value: self.radioID, fieldNumber: 1)
    }
    if self.includeDefaultCapabilities != false {
      try visitor.visitSingularBoolField(value: self.includeDefaultCapabilities, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Command.GetState, rhs: Arsdk_Connectivity_Command.GetState) -> Bool {
    if lhs.radioID != rhs.radioID {return false}
    if lhs.includeDefaultCapabilities != rhs.includeDefaultCapabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Command.SetMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Connectivity_Command.protoMessageName + ".SetMode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "radio_id"),
    2: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.radioID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.radioID != 0 {
      try visitor.visitSingularUInt32Field(value: self.radioID, fieldNumber: 1)
    }
    if self.mode != .ap {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Command.SetMode, rhs: Arsdk_Connectivity_Command.SetMode) -> Bool {
    if lhs.radioID != rhs.radioID {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Command.Scan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Connectivity_Command.protoMessageName + ".Scan"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "radio_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.radioID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.radioID != 0 {
      try visitor.visitSingularUInt32Field(value: self.radioID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Command.Scan, rhs: Arsdk_Connectivity_Command.Scan) -> Bool {
    if lhs.radioID != rhs.radioID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Command.Configure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Connectivity_Command.protoMessageName + ".Configure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "radio_id"),
    2: .standard(proto: "access_point_config"),
    3: .standard(proto: "station_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.radioID) }()
      case 2: try {
        var v: Arsdk_Connectivity_AccessPointConfig?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .accessPointConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .accessPointConfig(v)
        }
      }()
      case 3: try {
        var v: Arsdk_Connectivity_StationConfig?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .stationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .stationConfig(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.radioID != 0 {
      try visitor.visitSingularUInt32Field(value: self.radioID, fieldNumber: 1)
    }
    switch self.mode {
    case .accessPointConfig?: try {
      guard case .accessPointConfig(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .stationConfig?: try {
      guard case .stationConfig(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Command.Configure, rhs: Arsdk_Connectivity_Command.Configure) -> Bool {
    if lhs.radioID != rhs.radioID {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    16: .standard(proto: "radio_list"),
    17: .same(proto: "state"),
    18: .standard(proto: "command_response"),
    19: .same(proto: "connection"),
    20: .standard(proto: "scan_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 16: try {
        var v: Arsdk_Connectivity_Event.RadioList?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .radioList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .radioList(v)
        }
      }()
      case 17: try {
        var v: Arsdk_Connectivity_Event.State?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .state(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .state(v)
        }
      }()
      case 18: try {
        var v: Arsdk_Connectivity_Event.CommandResponse?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .commandResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .commandResponse(v)
        }
      }()
      case 19: try {
        var v: Arsdk_Connectivity_Event.Connection?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .connection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .connection(v)
        }
      }()
      case 20: try {
        var v: Arsdk_Connectivity_Event.ScanResult?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .scanResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .scanResult(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .radioList?: try {
      guard case .radioList(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .state?: try {
      guard case .state(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .commandResponse?: try {
      guard case .commandResponse(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .connection?: try {
      guard case .connection(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .scanResult?: try {
      guard case .scanResult(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Event, rhs: Arsdk_Connectivity_Event) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Event.RadioList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Connectivity_Event.protoMessageName + ".RadioList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "radios"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufUInt32,Arsdk_Connectivity_RadioType>.self, value: &self.radios) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.radios.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufUInt32,Arsdk_Connectivity_RadioType>.self, value: self.radios, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Event.RadioList, rhs: Arsdk_Connectivity_Event.RadioList) -> Bool {
    if lhs.radios != rhs.radios {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Event.State: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Connectivity_Event.protoMessageName + ".State"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "radio_id"),
    2: .standard(proto: "default_capabilities"),
    3: .standard(proto: "access_point_config"),
    4: .standard(proto: "station_config"),
    5: .same(proto: "idle"),
    6: .standard(proto: "access_point"),
    7: .same(proto: "station"),
    8: .same(proto: "channel"),
    9: .standard(proto: "authorized_channels"),
    10: .same(proto: "rssi"),
  ]

  fileprivate class _StorageClass {
    var _radioID: UInt32 = 0
    var _defaultCapabilities: Arsdk_Connectivity_Capabilities? = nil
    var _accessPointConfig: Arsdk_Connectivity_AccessPointConfig? = nil
    var _stationConfig: Arsdk_Connectivity_StationConfig? = nil
    var _mode: Arsdk_Connectivity_Event.State.OneOf_Mode?
    var _channel: Arsdk_Connectivity_Channel? = nil
    var _authorizedChannels: Arsdk_Connectivity_AuthorizedChannels? = nil
    var _rssi: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _radioID = source._radioID
      _defaultCapabilities = source._defaultCapabilities
      _accessPointConfig = source._accessPointConfig
      _stationConfig = source._stationConfig
      _mode = source._mode
      _channel = source._channel
      _authorizedChannels = source._authorizedChannels
      _rssi = source._rssi
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._radioID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._defaultCapabilities) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._accessPointConfig) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._stationConfig) }()
        case 5: try {
          var v: Arsdk_Connectivity_IdleState?
          var hadOneofValue = false
          if let current = _storage._mode {
            hadOneofValue = true
            if case .idle(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._mode = .idle(v)
          }
        }()
        case 6: try {
          var v: Arsdk_Connectivity_AccessPointState?
          var hadOneofValue = false
          if let current = _storage._mode {
            hadOneofValue = true
            if case .accessPoint(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._mode = .accessPoint(v)
          }
        }()
        case 7: try {
          var v: Arsdk_Connectivity_StationState?
          var hadOneofValue = false
          if let current = _storage._mode {
            hadOneofValue = true
            if case .station(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._mode = .station(v)
          }
        }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._channel) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._authorizedChannels) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._rssi) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._radioID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._radioID, fieldNumber: 1)
      }
      try { if let v = _storage._defaultCapabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._accessPointConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._stationConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      switch _storage._mode {
      case .idle?: try {
        guard case .idle(let v)? = _storage._mode else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .accessPoint?: try {
        guard case .accessPoint(let v)? = _storage._mode else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .station?: try {
        guard case .station(let v)? = _storage._mode else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case nil: break
      }
      try { if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._authorizedChannels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._rssi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Event.State, rhs: Arsdk_Connectivity_Event.State) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._radioID != rhs_storage._radioID {return false}
        if _storage._defaultCapabilities != rhs_storage._defaultCapabilities {return false}
        if _storage._accessPointConfig != rhs_storage._accessPointConfig {return false}
        if _storage._stationConfig != rhs_storage._stationConfig {return false}
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._authorizedChannels != rhs_storage._authorizedChannels {return false}
        if _storage._rssi != rhs_storage._rssi {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Event.CommandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Connectivity_Event.protoMessageName + ".CommandResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "radio_id"),
    2: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.radioID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.radioID != 0 {
      try visitor.visitSingularUInt32Field(value: self.radioID, fieldNumber: 1)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Event.CommandResponse, rhs: Arsdk_Connectivity_Event.CommandResponse) -> Bool {
    if lhs.radioID != rhs.radioID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Event.Connection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Connectivity_Event.protoMessageName + ".Connection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "radio_id"),
    2: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.radioID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.radioID != 0 {
      try visitor.visitSingularUInt32Field(value: self.radioID, fieldNumber: 1)
    }
    if self.status != .disconnected {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Event.Connection, rhs: Arsdk_Connectivity_Event.Connection) -> Bool {
    if lhs.radioID != rhs.radioID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Event.ScanResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Connectivity_Event.protoMessageName + ".ScanResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "radio_id"),
    2: .same(proto: "networks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.radioID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.networks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.radioID != 0 {
      try visitor.visitSingularUInt32Field(value: self.radioID, fieldNumber: 1)
    }
    if !self.networks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.networks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Event.ScanResult, rhs: Arsdk_Connectivity_Event.ScanResult) -> Bool {
    if lhs.radioID != rhs.radioID {return false}
    if lhs.networks != rhs.networks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Capabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "supported_modes"),
    3: .standard(proto: "supported_encryption_types"),
    4: .standard(proto: "supported_countries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.supportedModes) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.supportedEncryptionTypes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.supportedCountries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.supportedModes.isEmpty {
      try visitor.visitPackedEnumField(value: self.supportedModes, fieldNumber: 2)
    }
    if !self.supportedEncryptionTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.supportedEncryptionTypes, fieldNumber: 3)
    }
    if !self.supportedCountries.isEmpty {
      try visitor.visitRepeatedStringField(value: self.supportedCountries, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Capabilities, rhs: Arsdk_Connectivity_Capabilities) -> Bool {
    if lhs.supportedModes != rhs.supportedModes {return false}
    if lhs.supportedEncryptionTypes != rhs.supportedEncryptionTypes {return false}
    if lhs.supportedCountries != rhs.supportedCountries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_AccessPointConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessPointConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "security"),
    2: .same(proto: "ssid"),
    3: .same(proto: "hidden"),
    4: .standard(proto: "hw_addr"),
    5: .same(proto: "country"),
    6: .same(proto: "environment"),
    7: .standard(proto: "manual_channel"),
    8: .standard(proto: "automatic_channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._security) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ssid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._hidden) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._hwAddr) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._country) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._environment) }()
      case 7: try {
        var v: Arsdk_Connectivity_Channel?
        var hadOneofValue = false
        if let current = self.channelSelectionType {
          hadOneofValue = true
          if case .manualChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.channelSelectionType = .manualChannel(v)
        }
      }()
      case 8: try {
        var v: Arsdk_Connectivity_AutomaticChannelSelection?
        var hadOneofValue = false
        if let current = self.channelSelectionType {
          hadOneofValue = true
          if case .automaticChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.channelSelectionType = .automaticChannel(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._security {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ssid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hidden {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._hwAddr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._country {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._environment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    switch self.channelSelectionType {
    case .manualChannel?: try {
      guard case .manualChannel(let v)? = self.channelSelectionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .automaticChannel?: try {
      guard case .automaticChannel(let v)? = self.channelSelectionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_AccessPointConfig, rhs: Arsdk_Connectivity_AccessPointConfig) -> Bool {
    if lhs._security != rhs._security {return false}
    if lhs._ssid != rhs._ssid {return false}
    if lhs._hidden != rhs._hidden {return false}
    if lhs._hwAddr != rhs._hwAddr {return false}
    if lhs._country != rhs._country {return false}
    if lhs._environment != rhs._environment {return false}
    if lhs.channelSelectionType != rhs.channelSelectionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_StationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StationConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "security"),
    2: .same(proto: "ssid"),
    3: .same(proto: "hidden"),
    4: .standard(proto: "hw_addr"),
    5: .same(proto: "country"),
    6: .same(proto: "environment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._security) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ssid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._hidden) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._hwAddr) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._country) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._environment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._security {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ssid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hidden {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._hwAddr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._country {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._environment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_StationConfig, rhs: Arsdk_Connectivity_StationConfig) -> Bool {
    if lhs._security != rhs._security {return false}
    if lhs._ssid != rhs._ssid {return false}
    if lhs._hidden != rhs._hidden {return false}
    if lhs._hwAddr != rhs._hwAddr {return false}
    if lhs._country != rhs._country {return false}
    if lhs._environment != rhs._environment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_IdleState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdleState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_IdleState, rhs: Arsdk_Connectivity_IdleState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_AccessPointState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessPointState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "system_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.systemState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.systemState != .stopping {
      try visitor.visitSingularEnumField(value: self.systemState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_AccessPointState, rhs: Arsdk_Connectivity_AccessPointState) -> Bool {
    if lhs.systemState != rhs.systemState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_StationState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StationState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "system_state"),
    2: .standard(proto: "connection_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.systemState) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.connectionState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.systemState != .stopping {
      try visitor.visitSingularEnumField(value: self.systemState, fieldNumber: 1)
    }
    if self.connectionState != .connecting {
      try visitor.visitSingularEnumField(value: self.connectionState, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_StationState, rhs: Arsdk_Connectivity_StationState) -> Bool {
    if lhs.systemState != rhs.systemState {return false}
    if lhs.connectionState != rhs.connectionState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Channel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wifi_channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Arsdk_Connectivity_WifiChannel?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .wifiChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .wifiChannel(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .wifiChannel(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Channel, rhs: Arsdk_Connectivity_Channel) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_WifiChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "band"),
    2: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.band) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.band != .wifiBand24Ghz {
      try visitor.visitSingularEnumField(value: self.band, fieldNumber: 1)
    }
    if self.channel != 0 {
      try visitor.visitSingularUInt32Field(value: self.channel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_WifiChannel, rhs: Arsdk_Connectivity_WifiChannel) -> Bool {
    if lhs.band != rhs.band {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_AuthorizedChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizedChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_AuthorizedChannels, rhs: Arsdk_Connectivity_AuthorizedChannels) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_AuthorizedChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizedChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "environment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.environment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.environment != .indoor {
      try visitor.visitSingularEnumField(value: self.environment, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_AuthorizedChannel, rhs: Arsdk_Connectivity_AuthorizedChannel) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.environment != rhs.environment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_NetworkSecurityMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkSecurityMode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encryption"),
    2: .same(proto: "passphrase"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.encryption) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.passphrase) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encryption.isEmpty {
      try visitor.visitPackedEnumField(value: self.encryption, fieldNumber: 1)
    }
    if !self.passphrase.isEmpty {
      try visitor.visitSingularStringField(value: self.passphrase, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_NetworkSecurityMode, rhs: Arsdk_Connectivity_NetworkSecurityMode) -> Bool {
    if lhs.encryption != rhs.encryption {return false}
    if lhs.passphrase != rhs.passphrase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Network: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Network"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "encryption"),
    3: .same(proto: "ssid"),
    4: .same(proto: "bie"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.encryption) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ssid) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bie) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.encryption.isEmpty {
      try visitor.visitPackedEnumField(value: self.encryption, fieldNumber: 2)
    }
    if !self.ssid.isEmpty {
      try visitor.visitSingularStringField(value: self.ssid, fieldNumber: 3)
    }
    if !self.bie.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bie, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Network, rhs: Arsdk_Connectivity_Network) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.encryption != rhs.encryption {return false}
    if lhs.ssid != rhs.ssid {return false}
    if lhs.bie != rhs.bie {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_Bie: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Bie"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oui"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.oui) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oui.isEmpty {
      try visitor.visitSingularBytesField(value: self.oui, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_Bie, rhs: Arsdk_Connectivity_Bie) -> Bool {
    if lhs.oui != rhs.oui {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_EnvironmentValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnvironmentValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .indoor {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_EnvironmentValue, rhs: Arsdk_Connectivity_EnvironmentValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Connectivity_AutomaticChannelSelection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutomaticChannelSelection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_bands"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.allowedBands) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedBands.isEmpty {
      try visitor.visitPackedEnumField(value: self.allowedBands, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Connectivity_AutomaticChannelSelection, rhs: Arsdk_Connectivity_AutomaticChannelSelection) -> Bool {
    if lhs.allowedBands != rhs.allowedBands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
